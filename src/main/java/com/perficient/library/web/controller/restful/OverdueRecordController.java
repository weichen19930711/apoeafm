package com.perficient.library.web.controller.restful;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.time.DateFormatUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.perficient.library.common.annotation.PermissionRequired;
import com.perficient.library.common.utils.MailTemplateUtils;
import com.perficient.library.common.utils.MailUtils;
import com.perficient.library.common.utils.PageUtils;
import com.perficient.library.common.utils.ReturnResultUtils;
import com.perficient.library.core.enums.Role;
import com.perficient.library.core.exception.RestServiceException;
import com.perficient.library.core.model.BookProperty;
import com.perficient.library.core.model.BorrowRecord;
import com.perficient.library.core.model.Employee;
import com.perficient.library.core.model.OverdueRecord;
import com.perficient.library.core.model.vo.OverdueRecordVo;
import com.perficient.library.core.service.EmployeeService;
import com.perficient.library.core.service.OverdueRecordService;
import com.perficient.library.mail.model.MailQueue;
import com.perficient.library.mail.model.MailTemplate;
import com.perficient.library.mail.service.MailQueueService;
import com.perficient.library.mail.service.MailTemplateService;
import com.perficient.library.web.domain.Pagination;
import com.perficient.library.web.domain.ReturnResult;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;

/**
 * Only Librarian can do operations for overdue records.
 * 
 * @author bin.zhou
 *
 */
@RestController
@RequestMapping("/api/v1/overdue_record")
@Api("overdue_record")
public class OverdueRecordController {

    @Autowired
    private OverdueRecordService overdueRecordService;

    @Autowired
    private MailTemplateService mailTemplateService;

    @Autowired
    private EmployeeService employeeService;

    @Autowired
    private MailQueueService mailQueueService;

    @Value("${library.sso.front-end.base-url}")
    private String frontEndURL;

    // add operation will be auto generated by timer task

    // cannot update overdue record, because it was auto generated

    @DeleteMapping("/{recordId}")
    @ApiOperation("(Librarian Only) delete a overdue record by overdue record id")
    @PermissionRequired(role = Role.LIBRARIAN)
    public ReturnResult<String> deleteOverdueRecord(@PathVariable("recordId") Integer recordId) {
        OverdueRecord overdueRecord = null;

        // Overdue record's id must exist
        if ((overdueRecord = overdueRecordService.findOne(recordId)) == null) {
            throw new RestServiceException("overdue record is not exist");
        }

        // If the associated book has not been checked in, the overdue record
        // cannot be deleted
        if (!overdueRecord.isReturned()) {
            throw new RestServiceException("the associated book has not been checked in");
        }

        overdueRecordService.delete(recordId);
        return ReturnResultUtils.success("delete succeeded", null);
    }

    @GetMapping
    @ApiOperation("(Librarian Only) get all overdue records")
    @PermissionRequired(role = Role.LIBRARIAN)
    public ReturnResult<List<OverdueRecord>> findAllOverdueRecords(
        @RequestParam(value = "page", required = false) Integer page,
        @RequestParam(value = "size", required = false) Integer size,
        @RequestParam(value = "searchValue", required = false) String searchValue) {

        Pageable pageable = PageUtils.buildPageRequest(Pagination.generatePagnation(page, size));
        Specification<OverdueRecord> spec = PageUtils.buildSpecificationForOverdueRecord(searchValue);
        Page<OverdueRecord> records = overdueRecordService.findOverdueRecordsBySearchValue(spec, pageable);
        return ReturnResultUtils.successPaged(records.getContent(), records.getTotalElements());
    }

    @GetMapping("/no_return")
    @ApiOperation("(Librarian Only) get not checked in overdue records")
    @PermissionRequired(role = Role.LIBRARIAN)
    public ReturnResult<List<OverdueRecord>> findNotCheckedInOverdueRecords(
        @RequestParam(value = "page", required = false) Integer page,
        @RequestParam(value = "size", required = false) Integer size,
        @RequestParam(value = "searchValue", required = false) String searchValue,
        @RequestParam(value = "key", required = false) String key,
        @RequestParam(value = "order", required = false) String order) {
        Pagination pagnation = Pagination.generatePagnation(page, size);
        PageRequest pageable = null;
        if (Direction.ASC.toString().equalsIgnoreCase(order)) {
            pageable = PageUtils.buildPageRequest(pagnation, Direction.ASC, key);
        } else {
            pageable = PageUtils.buildPageRequest(pagnation, Direction.DESC, key);
        }
        Specification<OverdueRecord> spec = PageUtils.buildSpecificationForOverdueRecord(searchValue);
        Page<OverdueRecord> records = overdueRecordService.findOverdueRecordsBySearchValue(spec, pageable);
        return ReturnResultUtils.successPaged(records.getContent(), records.getTotalElements());
    }

    @GetMapping("/export")
    @ApiOperation("(Librarian Only) export overdue records")
    @PermissionRequired(role = Role.LIBRARIAN)
    public void exportCheckedOutBorrowRecord(@RequestParam(value = "searchValue", required = false) String searchValue,
        @RequestParam(value = "key", required = false) String key,
        @RequestParam(value = "order", required = false) String order) {
        Specification<OverdueRecord> spec = PageUtils.buildSpecificationForOverdueRecord(searchValue);
        List<OverdueRecordVo> recordVos = new ArrayList<OverdueRecordVo>();
        Integer size = (int) overdueRecordService.findOverdueRecordsBySearchValue(spec, null).getTotalElements();
        // if no data in database.
        if (size == 0) {
            overdueRecordService.exportOverdueRecord(recordVos);
        } else {
            Pagination pagnation = Pagination.generatePagnation(1, size);
            PageRequest pageable = null;
            if (Direction.ASC.toString().equalsIgnoreCase(order)) {
                pageable = PageUtils.buildPageRequest(pagnation, Direction.ASC, key);
            } else {
                pageable = PageUtils.buildPageRequest(pagnation, Direction.DESC, key);
            }
            Page<OverdueRecord> records = overdueRecordService.findOverdueRecordsBySearchValue(spec, pageable);
            for (OverdueRecord record : records.getContent()) {
                recordVos.add(new OverdueRecordVo(record));
            }
            overdueRecordService.exportOverdueRecord(recordVos);
        }
    }

    @PostMapping("/mail")
    @ApiOperation("(Librarian Only) trigger overdue mail reminder manually")
    @PermissionRequired(role = Role.LIBRARIAN)
    public ReturnResult<String> triggerMailReminder(@RequestParam("recordIds") Integer[] ids) {

        for (Integer id : ids) {
            OverdueRecord overdueRecord = null;

            // Overdue record's id must exist
            if ((overdueRecord = overdueRecordService.findOne(id)) == null) {
                continue;
            }

            if (overdueRecord.isReturned()) {
                continue;
            }

            BorrowRecord borrowRecord = overdueRecord.getBorrowRecord();
            BookProperty property = borrowRecord.getBook().getProperty();
            String screenName = borrowRecord.getEmployee().getScreenName();
            String bookDetailURL = frontEndURL + "/book/" + property.getId();
            String bookTitle = property.getTitle();
            Date dueDate = borrowRecord.getDueDate();

            // generate librarianNames and librarianMails
            Pageable pageable = PageUtils.buildPageRequest(Pagination.generatePagnation(null, null));
            Page<Employee> librarianResult = employeeService.findByRole(Role.LIBRARIAN, pageable);
            List<Employee> librarianList = librarianResult.getContent();

            if (librarianList.size() > 3) {
                librarianList = librarianList.subList(0, 3);
            }

            String librarianMails = MailTemplateUtils.buildLibrarianMails(librarianList);
            String librarianNames = MailTemplateUtils.buildLibrarianNames(librarianList);

            // build variable map
            Map<String, Object> varMap = new HashMap<>();
            varMap.put("employeeName", screenName);
            varMap.put("bookDetailURL", bookDetailURL);
            varMap.put("bookTitle", bookTitle);
            varMap.put("dueDate", DateFormatUtils.ISO_DATE_FORMAT.format(dueDate));
            varMap.put("librarianNames", librarianNames);
            varMap.put("librarianMails", librarianMails);

            MailTemplate template = mailTemplateService.findByName(MailTemplateUtils.OVERDUE_REMINDER_MAIL_NAME);

            MailQueue queue = MailTemplateUtils.buildQueue(template, varMap);
            // add stakeholder to sendTo list
            queue.getSendTo().add(MailUtils.getMail(screenName));

            mailQueueService.save(queue);
        }

        return ReturnResultUtils.success("send overdue reminder succeeded");
    }

}
